# IntersectionObserver API

时间：2023.9.7

当网页动效较多，常常需要对某些元素是否进入了视口（viewport）进行判断。往往我们采用的方式是通过监听scroll事件、通过类似这样的代码进行判断。

```js
const isElementInViewport = (element) => {
  const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
  const scrollTop = document.documentElement.scrollTop
  return element.offsetTop - scrollTop <= viewPortHeight
}
```

或者

```js
const isElementInViewport = (el) => {
  const rect = el.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document. documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document. documentElement.clientWidth)
  );
}
```

or

```js
function isElementInViewport(el) {
  var rect = el.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document. documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document. documentElement.clientWidth)
  );
}
```

查阅文档还有一种方法：`IntersectionObserver` API

IntersectionObserver API 提供了一种异步检测目标元素与祖先元素或相交情况变化的方法。在目标元素与视口或者其他指定元素发生交集时和触发配置的回调函数。

:::tip
但是要注意的一点是：IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。

IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。
:::

参考：

[阮一峰 Intersection Observer API](https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html)

[MDN Intersection Observer API](https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API)